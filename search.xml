<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Vijos P1037 构建双塔]]></title>
      <url>http://soyjuice.tk/2016/10/27/Vijos-p1037-%E5%8F%8C%E5%A1%94%E6%9E%84%E5%BB%BA/</url>
      <content type="text"><![CDATA[描述2001年9月11日，一场突发的灾难将纽约世界贸易中心大厦夷为平地，Mr.F曾亲眼目睹了这次灾难。为了纪念“9?11”事件，Mr. F决定自己用水晶来搭建一座双塔。Mr. F有N块水晶，每块水晶有一个高度，他想用这N块水晶搭建两座有同样高度的塔，使他们成为一座双塔，Mr. F可以从这N块水晶中任取M（1≤M≤N）块来搭建。但是他不知道能否使两座塔有同样的高度，也不知道如果能搭建成一座双塔，这座双塔的最大高度是多少。所以他来请你帮忙。给定水晶的数量N（1≤N≤100）和每块水晶的高度Hi（N块水晶高度的总和不超过2000），你的任务是判断Mr. F能否用这些水晶搭建成一座双塔（两座塔有同样的高度），如果能，则输出所能搭建的双塔的最大高度，否则输出“Impossible”。 格式输入格式输入的第一行为一个数N，表示水晶的数量。第二行为N个数，第i个数表示第i个水晶的高度。 输出格式输出仅包含一行，如果能搭成一座双塔，则输出双塔的最大高度，否则输出一个字符串“Impossible”。 样例1样例输入151 3 4 5 2 样例输出17 来源某校NOIP模拟题 分析题目分析：数据太水，暴力。 算法分析：暴力。 数据分析：太水。 代码分析：#include&lt;cstdio> using namespace std; bool inq[N][N]; int u,n,sum,x; int main() { scanf("%d",&amp;n); inq[0][0]=1; for(int k=0;k&lt;n;k++) { scanf("%d",&amp;x); for(int i=sum;i>-1;i--) for(int j=i;j>-1;j--) if(inq[i][j]) { if(j+x&lt;=i) inq[i][j+x]=1; else inq[j+x][i]=1; inq[i+x][j]=1; } sum+=x; } for(int i=sum;i>0;i--) if(inq[i][i]) { printf("%d\n",i); return 0; } puts("Impossible"); return 0; } 无。 。。。。。。。 好吧，标签暴露一切，本题还有动归解法。 分析2题目分析：从题目看似乎一下子想不到正解，这恰恰就证明了此题是动归。（滑稽 算法分析：动态规划，一看便是背包方面的问题，每一块水晶只有不取，放高塔或放低塔三种状态：1.f[i][j]表示前i块水晶，高度差为j时，较矮的塔的高度，sum[i]表示前缀和2.对于第i块水晶有四种操作：加在高塔上；加在低塔上，但仍为低塔；加在低塔上，成为高塔；不放这块水晶。3.f[i][j]从f[i-1][h]推来，就要从以上四种情况中确定h4.把f[i][j]初始化为负数，因为要保证f[i-1][h]这种情况是存在的，sum[]也是为了保证情况存在。 数据分析：太水，在动归面前显得更水了。 代码分析：#include&lt;bits/stdc++.h> using namespace std; const int up=300; int N; int a[300],sum[300]; int f[300][2500]; int main() { memset(f,-0x7f,sizeof f); cin>>N; for(int i=1;i&lt;=N;i++) cin>>a[i]; sort(a+1,a+N+1); for(int i=1;i&lt;=N;i++) sum[i]=sum[i-1]+a[i]; f[1][0]=0;f[1][a[1]]=0; for(int i=2;i&lt;=N;i++) { for(int j=0;j&lt;=sum[i];j++) { int h1=j-a[i]; if(h1>=0&amp;&amp;h1&lt;=sum[i-1]) f[i][j]=max(f[i][j],f[i-1][h1]); int h2=j+a[i]; if(h2&lt;=sum[i-1]) f[i][j]=max(f[i][j],f[i-1][h2]+a[i]); int h3=a[i]-j; if(h3>=0&amp;&amp;h3&lt;=sum[i-1]) f[i][j]=max(f[i][j],f[i-1][h3]+h3); int h4=j; if(h4&lt;=sum[i-1]) f[i][j]=max(f[i][j],f[i-1][j]); } } if(f[N][0]&lt;=0) { cout&lt;&lt;"Impossible"; return 0; } cout&lt;&lt;f[N][0]; return 0; } 做这道题总是让我想起逝去的青春，那一个夜晚，写下金明的预算方案时，那激动而又不满足的心情，错误时一遍又一遍纠错。 想必每一次AC都是珍贵的回忆吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于图论的第2优解]]></title>
      <url>http://soyjuice.tk/2016/10/25/%E5%85%B3%E4%BA%8E%E5%9B%BE%E8%AE%BA%E7%9A%84%E7%AC%ACk%E4%BC%98%E8%A7%A3/</url>
      <content type="text"><![CDATA[正常思路是spfa找最短路，再拆最短路上的边走spfa，保存最小值。 (本来我准备以玛丽卡为例题，鬼知道它是拆完边后保存最大值，讲道理，就应该是最坏情况) 正如最近的博文所述，也可以用多路归并解决。 #include&lt;bits/stdc++.h> using namespace std; const int maxN=1000+5,maxM=1000000+5,maxK=5,INF=0x7F7F7F7F; struct Edge { int a,b,dist; }; vector G[maxN]; vector edges; queue Q; bool inq[maxN][maxN]; int f[maxN][maxK]; int K=2,T[maxK],N,M; int q1,q2,a1,a2; void merge(int*,int*,int); int main() { int u,v,d,now,ans=0; scanf("%d %d",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=K;j++) f[i][j]=INF; f[1][1]=0; for(int i=0;i&lt;M;i++) { scanf("%d %d %d",&amp;u,&amp;v,&amp;d); edges.push_back((Edge){u,v,d}); G[u].push_back(i);G[v].push_back(i); } Q.push(1); while(!Q.empty()) { now=Q.front();Q.pop(); for(int i=G[now].size()-1;i>=0;i--) { Edge&amp; e=edges[G[now][i]]; if(now==e.a) v=e.b;else v=e.a; if(inq[now][v]) continue; inq[now][v]=1; Q.push(v); merge(f[v],f[now],e.dist); } } cout&lt;&lt;f[N][K]&lt;&lt;endl; return 0; } void merge(int* A,int* B,int C) { q1=1,q2=1; for(int i=1;i&lt;=K;i++) { a1=A[q1],a2=B[q2]+C; if(a1>a2) T[i]=a2,q2++; else T[i]=a1,q1++; } for(int i=1;i&lt;=K;i++) A[i]=T[i]; } 上述代码无法保证正确，但我相信算法才是最重要的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vijos P1412 多人背包]]></title>
      <url>http://soyjuice.tk/2016/10/25/vijos-p1412-%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85/</url>
      <content type="text"><![CDATA[【描述】DD 和好朋友们要去爬山啦！他们一共有 K 个人，每个人都会背一个包。这些包的容量是相同的，都是 V。可以装进背包里的一共有 N 种物品，每种物品都有给定的体积和价值。 在 DD 看来，合理的背包安排方案是这样的： 每个人背包里装的物品的总体积恰等于包的容量。每个包里的每种物品最多只有一件，但两个不同的包中可以存在相同的物品。任意两个人，他们包里的物品清单不能完全相同。在满足以上要求的前提下，所有包里的所有物品的总价值最大是多少呢？ 【格式】输入格式第一行有三个整数：K、V、N( 1 &lt;= K &lt;= 50， 0 &lt;= V &lt;= 5000，1 &lt;= N &lt;= 200 )。 第二行开始的 N 行，每行有两个整数，分别代表这件物品的体积和价值。 输出格式只需输出一个整数，即在满足以上要求的前提下所有物品的总价值的最大值。 【样例】输入样例2 10 53 127 202 45 61 1 输出样例57 【限制】各个测试点1s 【来源】dd_engi大神 【分析】题目分析：刚看题目，可以发现又是最优k解（为什么是“又”），那么就可以尝试以最优k解为模板来建立相同的模型。 算法分析：首先，是每个有序表代表着什么。根据模板，每个有序表代表着一个状态（可能是容量，行列）的解集，不妨假设有序表f[V]代表容量为V时的解集{f(V,1),f(V,2)…f(V,k)}。 那么，这个假设正确吗？答案是确定的，就像上一篇博文所说，最优k解的原理是多个有序表的合并，考虑到了所有的解，因而有序表首先要满足是包含所有的解或优于其它的解，这种假设显然是正确的。 接下来就要考虑有序表的合并，这里就应该将上一篇博文的算法一般化。 void merge(int* A,int* B,int C) { q1=1,q2=1; for(int i=1;i=v;j--) if(f[j-v][1]>-1) merge(f[j],f[j-v],a); } for(int i=1;i]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UVa 11997 K Smallest Sums]]></title>
      <url>http://soyjuice.tk/2016/10/24/uva-11997-k-smallest-sums/</url>
      <content type="text"><![CDATA[DescriptionYou’re given k arrays, each array has k integers. There are kk ways to pick exactly one element in each array and calculate the sum of the integers. Your task is to find the k smallest sums among them. 你被赋予了k个数组，每个数组都有k个整数。有kk的方式去在每个数组中挑选一个数，然后计算这些整数之和。你的任务是找到他们之间的最小的和。 InputThere will be several test cases. The first line of each case contains an integer k (2 ≤ k ≤ 750). Each of the following k lines contains k positive integers in each array. Each of these integers does not exceed 1,000,000. The input is terminated by end-of-file (EOF). 将有几个测试数据。每个数据的第一行包含一个整数k（2≤k≤750）。每个下面的K行中包含每个数组中的k个正整数。这些整数中的每一个不超过1000000。输入EOF结束（EOF）。 OutputFor each test case, print the k smallest sums, in ascending order. 对于每一个测试数据，输出最小的和，以递增的顺序。 Sample Input31 8 59 2 510 7 621 11 2 Sample Output9 10 122 2 注：以上翻译取自机翻，加上我的修改，应该勉强能看。 题目分析：非常简单明了的题意，如果是最优解，可以直接从每个序列选取最大值，但是由于是前优K解，所以没法这么直接。 算法分析：对于前优K解，根据刘汝佳大神的方法，可以用多路归并解决。 解决这个问题之前，可以先考虑它的简化版：给出两个长度为n的有序表A,B各取一个数，可以有n2个和，求最小的前n个和。 我们可以将这n2个和分成n个有序表 表1：A1+B1 &lt;= A1+B2 &lt;= A1+B3 &lt;= …表2：A2+B1 &lt;= A2+B2 &lt;= A2+B3 &lt;= …表3：A3+B1 &lt;= A3+B2 &lt;= A3+B3 &lt;= … 可以看出当A,B递增时，上表也是递增。 可以用二元组(s,b)表示一个元素，其中s=Aa+Ab。当需要某个表中的下一个元素(s’,b+1)时，只需要 s’=Aa+Bb+1=Aa+Bb-Bb+Bb+1=s-Bb+Bb+1 因此，定义下面这个结构体来表示上述二元组。 struct Item { int s,b; Item(int s,int b):s(s),b(b){} bool operator &lt; (const Item&amp; rhs) const { return s > rhs.s; } }; 每次读入一组数据时，将表合并，取n次最小值；因为在取出表1的元素之前，表2对应位置的数一定要大，一定不是当前的最小值，所以当取出这个元素后，再将它同列的下一个元素入队。 void merge(int* A,int* B,int* C,int n) { priority_queue q; for(int i=0;i&lt;n;i++) q.push(Item(A[i]+B[0],0)); for(int i=0;i&lt;n;i++) { Item item=q.top();q.pop(); C[i]=item.s; int b=item.b; if(b+1&lt;n) q.push(Item(item.s-B[b]+B[b+1],b+1)); } } 这样，两个表的问题就解决了。如果是多个表的话，两两合并就可以。 数据分析：k&lt;=750，并不算特别大，优先队列完全可以承受。 代码分析： #include&lt;bits/stdc++.h> using namespace std; const int maxn=768; int A[maxn][maxn]; struct Item { int s,b; Item(int s,int b):s(s),b(b){} bool operator &lt; (const Item&amp; rhs) const { return s > rhs.s; } }; void merge(int* A,int* B,int* C,int n) { priority_queue q; for(int i=0;i&lt;n;i++) q.push(Item(A[i]+B[0],0)); for(int i=0;i&lt;n;i++) { Item item=q.top();q.pop(); C[i]=item.s; int b=item.b; if(b+1&lt;n) q.push(Item(item.s-B[b]+B[b+1],b+1)); } } int main() { int n; while(scanf("%d",&amp;n)==1) { for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) scanf("%d",&amp;A[i][j]); sort(A[i],A[i]+n); } for(int i=1;i&lt;n;i++) merge(A[0],A[i],A[0],n); for(int i=0;i&lt;n;i++) printf("%d ",A[0][i]); printf("\n"); } return 0; } 多路归并可以广泛地运用于各种求最优k解，原理是将多个有序表合并成一个有序表，对于答案来说，其必然是一个有序表，故此算法正确，并将所有可能性考虑到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划专练（五）]]></title>
      <url>http://soyjuice.tk/2016/10/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E7%BB%83%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      <content type="text"><![CDATA[1.最长公共子序列(LCS)时间限制：3000 ms | 内存限制：65535 KB难度：3 | 提供网站：NYOJ (稍有改动) 描述咱们就不拐弯抹角了，如题，需要你做的就是写一个程序，得出最长公共子序列。tip：最长公共子序列也称作最长公共子串(不要求连续)，英文缩写为LCS（Longest Common Subsequence）。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。 输入第一行给出一个整数N(0&lt;N&lt;100)表示待测数据组数接下来每组数据两行，分别为待测的两组字符串。每个字符串长度不大于5000. 输出每组测试数据输出一个整数，表示最长公共子序列长度。每组结果占一行。 样例输入2asdfadfsd123abcabc123abc 样例输出36 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=5000 +5; char a[up],b[up];int k,l,f[2][up],T; int main() { scanf("%d",&amp;T); while(T--) { memset(f[0],0,sizeof f[0]); memset(f[1],0,sizeof f[1]); scanf("%s %s",a+1,b+1); k=strlen(a+1),l=strlen(b+1); for(int i=1;i&lt;=k;i++) for(int j=1;j&lt;=l;j++) if(a[i]==b[j]) f[i&amp;1][j]=f[(i-1)&amp;1][j-1]+1; else f[i&amp;1][j]=max(f[(i-1)&amp;1][j],f[i&amp;1][j-1]); printf("%d\n",f[k&amp;1][l]); } return 0; } 如果是直接开5000*5000的数组，内存是不够的，所以要用滚动数组进行优化。 用非常常用的k&amp;1优化，第一维保留这一排与上一排的状态，根据最长公共子序列问题的动态转移方程：如果a[i]=a[j]，f[i,j]=f[i-1,j-1]+1；否则，f[i,j]=max(f[i-1,j],f[i,j-1])。可以变成上面的 if(a[i]==b[j]) f[i&amp;1][j]=f[(i-1)&amp;1][j-1]+1;else f[i&amp;1][j]=max(f[(i-1)&amp;1][j],f[i&amp;1][j-1]); 2.最长上升子序列(LIS)时间限制：3000 ms | 内存限制：65535 KB难度：4 | 提供网站：NYOJ 描述求一个字符串的最长递增子序列的长度如：dabdbf最长递增子序列就是abdf，长度为4 输入第一行一个整数0&lt;n&lt;20,表示有n个字符串要处理随后的n行，每行有一个字符串，该字符串的长度不会超过10000 输出输出字符串的最长递增子序列的长度 样例输入3aaaababcabklmncdefg 样例输出137 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=10000 +5; int T,f[up],g[up]; char a[up]; int main() { int k,l,maxn=-1; scanf("%d",&amp;T); while(T--) { memset(g,0x7f,sizeof g); memset(f,0,sizeof f); maxn=-1; scanf("%s",a);l=strlen(a); for(int i=0;i&lt;l;i++) { k=lower_bound(g+1,g+l+1,a[i])-g; f[i]=k; g[k]=a[i]; maxn=max(maxn,f[i]); } printf("%d\n",maxn); } return 0; } 假设有两个状态a,b满足Aa&lt;Ab且d(a)=d(b)，则对于后续所有的状态，b都不会比a更优。 因此，如果只保留a一定不会丢失最优解，设g(i)表示d值为i的最小状态，不断更新，二分查找。 3.最大连续和题目描述 Description给定一个长度为n的一个序列A1，A2，…，An，求序列中连续子序列的最大和。例如：当输入为-5，3，5，7，-15，6，9，27，-36，10时，连续子序列6，9，27的和为42是最大值；而当序列变成-5，3，5，8，-15，6，9，27，-36，10时，连续子序列3，5，8，-15，6，9，27的和为43是最大值。 输入描述 Input Description第一行为n (n≤1000)，第二行为n个数，表示序列Ai（-10000≤Ai≤10000）。 输出描述 Output Description一个数，表示连续子序列的最大和。 样例输入 Sample Input10-5 3 5 8 -15 6 9 27 -36 10 样例输出 Sample Output43 数据范围及提示 Data Size &amp; Hint-10000≤Ai≤10000n≤1000 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=1000 +5; int T,f[up],a[up]; int main() { int maxn=-1; scanf("%d",&amp;T); for(int i=1;i&lt;=T;i++) { scanf("%d",&amp;a[i]); f[i]=max(0,f[i-1])+a[i]; maxn=max(maxn,f[i]); } printf("%d\n",maxn); return 0; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划专练（四）]]></title>
      <url>http://soyjuice.tk/2016/10/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E7%BB%83%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="text"><![CDATA[1.采药题目描述辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入格式第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出格式一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 输入样例70 371 10069 11 2 输出样例3 说明对于30%的数据，M &lt;= 10； 对于全部的数据，M &lt;= 100。 NOIP2005普及组第三题，也就是背包问题中的01背包。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=1000 +5; int main() { int t,m,ti,vi,f[up]; memset(f,0,sizeof f); scanf("%d %d",&amp;t,&amp;m); while(m--) { scanf("%d %d",&amp;ti,&amp;vi); for(int i=t;i&gt;=ti;i--) f[i]=max(f[i],f[i-ti]+vi); } printf("%d\n",f[t]); return 0; } 对于 背包问题，我个人是这么认为的： 首先，滚动数组（其实就是压了并不重要的一维）是必然的，而且背包问题滚动数组更容易理解。 在01背包中，循环由大到小，如“for(int i=C;i&gt;=V;i–) f[i]=max(f[i],f[i-V]+W);”，较末的状态转移自较前的状态是背包问题也是大部分动态规划题目的特点，而较末的状态先被计算，对同一个循环中的其它状态是不会有影响的，因为较前的状态只会转移自比它更前的状态；而在完全背包中，循环由小到大，如“for(int i=V;i&lt;=C;i++) f[i]=max(f[i],f[i-V]+W);”，较前的状态先被计算，于是就有可能对同一循环中之后的状态造成影响。 至于剩下的一些背包问题，则是万变不离其宗，比如多重背包，可以看作有同种物品的01背包，还有混合背包，也可以同样看作是不同多种物品的01背包。 2.点集配对问题问题描述空间里有n个点P0,P1,P2,…,Pn-1，把它们分成n/2对，使得每个点恰好在一个点对中，且所有点对距离之和尽量小。 输入格式第一行是整数n，数据保证n为偶数；接下来n行每行三个数，分别代表点i的x,y,z坐标。 输出格式输出只有一行，为最小的所有点对距离之和，保留两位小数。 输入样例41 1 11 1 21 4 31 6 6 输出样例4.61 说明n&lt;=20，|xi|,|yi|,|zi|&lt;=10000。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=20 +5; const double inf=1e10; struct node { int x,y,z; } g[up]; int n,k; double f[1&lt;&lt;up];//二进制集合表示状态 double dis(int i,int j) { return sqrt(((double)(g[i].x-g[j].x)*(g[i].x-g[j].x)+(g[i].y-g[j].y)*(g[i].y-g[j].y)+(g[i].z-g[j].z)*(g[i].z-g[j].z))); } int main() { scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d %d %d",&amp;g[i].x,&amp;g[i].y,&amp;g[i].z); for(int i=1;i&lt;(1&lt;&lt;n);i++) { f[i]=inf; for(k=0;k&lt;n;k++) if(i&amp;(1&lt;&lt;k)) break; for(int j(k+1);j&lt;n;j++) if(i&amp;(1&lt;&lt;j)) f[i]=min(f[i],dis(k,j)+f[i^(1&lt;&lt;j)^(1&lt;&lt;k)]); } printf("%.2lf",f[(1&lt;&lt;n)-1]); return 0; } 代码本身没有什么亮点，但有一处值得注意，当遇到集合DP时可以考虑使用二进制代表集合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NOIP模拟赛 T1 Number]]></title>
      <url>http://soyjuice.tk/2016/10/04/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B%20T1%20Number/</url>
      <content type="text"><![CDATA[【题目描述】给出一个整数x，你可以对x进行两种操作。1、将x变成4x+32、将x变成8x+7问，最少通过多少次操作，使得x是1000000007的倍数？ 【输入格式】一行，一个整数x(1&lt;=x&lt;=1000000006)。 【输出格式】一行，表示最少的操作步数。保证答案不超过10^5。 【样例输入1】125000000 【样例输出1】1 【样例输入2】281250001 【样例输出2】2 【样例输入3】18426114 【样例输出3】58 【样例输入4】705616876 【样例输出4】100000 【数据约定】对于50%的数据，答案不超过10对于80%的数据，答案不超过1000对于100%的数据，答案不超过100000 对于上面这道题，我第一次看到时，其实内心是崩溃的，这么诡的题，虽然知道是数学题，但还是毫无思路，只好拍上一个暴力，最后只得了50分，后来在学长提醒下发现做两次2等于做三次1： 8（8x+7）+7=64x+63；4（4（4x+3）+3）+3=64x+63； 再思考了一下，发现这仅仅只是开始： 2（2x+1）+1=4x+3；2（2（2x+1）+1）+1=8x+7； 那么就可以用2x+1代替1，2操作： cin&gt;&gt;num; while(true) { num=(num*2+1)%mod; kase++; if(num==0) break; } 输出答案时，又陷入了另一个问题，该如何输出？ switch(kase%2) { case 0: cout&lt;&lt;kase/3&lt;&lt;endl; break; case 1: cout&lt;&lt;kase/3-1+2&lt;&lt;endl; break; case 2: cout&lt;&lt;kase/3+1&lt;&lt;endl; break; } 一共有三种情况，难道真的需要上面这么做吗？ 归纳一下，(kase-1)/3+1就可以代替。 代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; const long long mod=1000000007; long long kase,num; int main() { cin&gt;&gt;num; while(true) { num=(num*2+1)%mod; kase++; if(num==0) break; } cout&lt;&lt;(kase-1)/3+1&lt;&lt;endl; return 0; } 那么这道题就迎刃而解了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划专练（三）]]></title>
      <url>http://soyjuice.tk/2016/10/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E7%BB%83%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="text"><![CDATA[1.矩形嵌套时间限制：3000 ms | 内存限制：65535 KB难度：4 | 提供网站：NYOJ 描述有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形X(a,b)可以嵌套在矩形Y(c,d)中当且仅当a&lt;c,b&lt;d或者b&lt;c,a&lt;d（相当于旋转X90度）。例如（1,5）可以嵌套在（6,2）内，但不能嵌套在（3,4）中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。 输入第一行是一个正正数N(0&lt;N&lt;10)，表示测试数据组数；每组测试数据的第一行是一个正正数n，表示该组测试数据中含有矩形的个数(n&lt;=1000)；随后的n行，每行有两个数a,b(0&lt;a,b&lt;100)，表示矩形的长和宽。 输出每组测试数据都输出一个数，表示最多符合条件的矩形数目，每组输出占一行。 样例输入1101 22 45 86 107 93 15 812 109 72 2 样例输出5 来源经典题目 上传者张云聪 代码（这里提供两份，一份记忆化搜索，一份DAG最长路标准套路）： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=1000 +5; struct matrix { int h,w; } a[up]; int f[up],n; int fi(int x) { if(f[x]) return f[x]; for(int j=1;j&lt;=n;j++) if(j==x) continue; else if((a[x].w&gt;a[j].w &amp;&amp; a[x].h&gt;a[j].h) || (a[x].h&gt;a[j].w &amp;&amp; a[x].w&gt;a[j].h)) f[x]=max(f[x],fi(j)+1); return f[x]; } int main() { int N,x,y,maxn; scanf("%d",&amp;N); while(N--) { scanf("%d",&amp;n);maxn=0;memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) scanf("%d %d",&amp;a[i].h,&amp;a[i].w); for(int i=1;i&lt;=n;i++) maxn=max(maxn,fi(i)); printf("%d\n",maxn+1); } return 0; } #include&lt;bits/stdc++.h&gt; using namespace std; const int up=1000 +5; struct matrix { int h,w; } a[up]; int f[up]; bool cmp(const matrix&amp; x,const matrix&amp; y) { return x.h&lt;y.h; } int main() { int N,n,x,y,maxn; scanf("%d",&amp;N); while(N--) { scanf("%d",&amp;n);maxn=0; memset(f,0,sizeof f); for(int i=1;i&lt;=n;i++) { scanf("%d %d",&amp;x,&amp;y); if(x&gt;y) a[i].h=y,a[i].w=x; else a[i].h=x,a[i].w=y; } sort(a+1,a+n+1,cmp); for(int i=2;i&lt;=n;i++) for(int j=1;j&lt;i;j++) if(a[i].w&gt;a[j].w &amp;&amp; a[i].h&gt;a[j].h) f[i]=max(f[i],f[j]+1); for(int i=1;i&lt;=n;i++) maxn=max(maxn,f[i]); printf("%d\n",maxn+1); } return 0; } 2.硬币问题描述有n种硬币，面值分别为V1,V2,…Vn,每种都有无限多。给定非负整数S，可以选用多少个硬币，使得面值之和恰好为S？输出硬币数目的最小值和最大值。 输入第一行是两个数n，S，1&lt;=n&lt;=100，0&lt;=S&lt;=10000；接下来n行是每一种硬币的面值Vi，1&lt;=Vi&lt;=S。 输出两行各一个整数，第一行是硬币数目最小值，第二行是硬币数目最大值。 样例输入5 1012457 样例输出210 来源ACM常见模型：DAG最长最短路，也可以看成完全背包。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up1=10000 +5,up2=100 +5,inf=0x3f3f3f3f; int f[up1],g[up1]; int V[up2]; int main() { int n,S,maxn; scanf("%d %d",&amp;n,&amp;S); for(int i=1;i&lt;=S;i++) f[i]=inf,g[i]=-inf; for(int i=1;i&lt;=n;i++) { scanf("%d",&amp;V[i]); for(int j=V[i];j&lt;=S;j++) f[j]=min(f[j],f[j-V[i]]+1),g[j]=max(g[j],g[j-V[i]]+1); } printf("%d\n%d",f[S],g[S]); return 0; } 3.信任链题目描述现在有一排人站成一列，然后开始玩游戏。 现在告诉你有N个人（编号成1到N，排成一列），每个人有一个唯一的数字P。如果有俩个人A和B， 如果B的P是A的编号的约数并且B的编号小于A，那么A就相信B。 现在要找出最长的信任链，即一系列人，每个人都信任他前面的一个人，序列可以不连续。 输入格式第一行一个数N。 下面一行N个数，表示每个人的唯一数字P。 输出格式输出最长的信任链的长度。 输入样例6 1 1 2 1 4 3 输出样例5 数据规模30%：N&lt;1000 100%：N0&lt;P&lt;=100 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int f[100005]; int a[105]; int main() { int n,maxn=0,x; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) f[i]=1; for(int i=1;i&lt;=n;i++) { scanf("%d",&amp;x); for(int j=min(i,100);j&gt;=1;j--) if(i%j==0) f[i]=max(f[i],a[j]+1); a[x]=max(a[x],f[i]); maxn=max(maxn,f[i]); } printf("%d\n",maxn); return 0; } 同样是DAG最长路，但又有一些改变，首先是状态转移的改变，其次是策略的改变。 当同样的数作为状态推出最优解时，只需考虑同一个数中的链较长的一个，因为比它小的就一定不是最优解。 若以f[i]表示以i为尾最长的信任链，那么可以再声明a[p]表示在i之前值为p的最长信任链的长度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[轻（lan）松（ren）预编译法]]></title>
      <url>http://soyjuice.tk/2016/09/29/%E8%BD%BB%EF%BC%88lan%EF%BC%89%E6%9D%BE%EF%BC%88ren%EF%BC%89%E9%A2%84%E7%BC%96%E8%AF%91%E6%B3%95/</url>
      <content type="text"><![CDATA[本文实属博主无聊时，发现的一种行之有效的轻松写代码的方法： #include&lt;bits/stdc++.h&gt; #define res(s,n) scanf("%"s,&amp;n) #define rep(s,n) printf("%"s"\n",n) #define ref(i,m,n) for(int i=m;i&lt;=n;i++) #define mfile(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout) #define lnt long long using namespace std; int main() { lnt n; res("lld",n); ref(i,1,n) rep("lld",n); return 0; } 看到上方这份代码，相信每个OIer都可以知道我这份代码的玄（tou）妙（lan）之处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划专练（二）]]></title>
      <url>http://soyjuice.tk/2016/09/26/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E7%BB%83%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="text"><![CDATA[1.数字三角形（一维数组）描述示出了一个数字三角形。 请编一个程序计算从顶至底的某处的一条路径，使该路径所经过的数字的总和最大。每一步可沿左斜线向下或右斜线向下走；1&lt;三角形行数&lt;25；三角形中的数字为整数&lt;1000； 输入格式第一行为N，表示有N行后面N行表示三角形每条路的路径权 输出格式路径所经过的数字的总和最大的答案 测试样例输入 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 输出 30 备注搜索80，记忆化AC。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=30; int main() { int a[up],f[up],n,ans=-1; memset(a,0,sizeof a); memset(f,0,sizeof f); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=i;j++) cin&gt;&gt;a[j]; for(int j=i;j&gt;=1;j--) f[j]=max(f[j],f[j-1])+a[j]; } for(int i=1;i&lt;=n;i++) ans=max(ans,f[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0; } 2.三取方格数背景JerryZhou同学经常改编习题给自己做。 这天，他又改编了一题。。。。。 描述设有N*N的方格图，我们将其中的某些方格填入正整数，而其他的方格中放入0。 某人从图得左上角出发，可以向下走，也可以向右走，直到到达右下角。 在走过的路上，他取走了方格中的数。（取走后方格中数字变为0）此人从左上角到右下角共走3次，试找出3条路径，使得取得的数总和最大。 格式输入格式第一行:N (4&lt;=N&lt;=20)接下来一个N*N的矩阵，矩阵中每个元素不超过80，不小于0 输出格式一行，表示最大的总和。 测试样例样例输入41 2 3 42 1 3 41 2 3 41 3 2 4 样例输出39 限制各个测试点1s 提示多进程DP 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=20 +5; int n,a[up][up],f[2*up][up][up][up]; int main() { scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); f[1][1][1][1]=a[1][1]; for(int s=2;s&lt;=2*n-1;s++) for(int x1=max(1,s-n+1);x1&lt;=min(n,s);x1++) for(int x2=max(1,s-n+1);x2&lt;=min(n,s);x2++) for(int x3=max(1,s-n+1);x3&lt;=min(n,s);x3++) { //s=x+y-1 int mid=a[x1][s-x1+1]+a[x2][s-x2+1]+a[x3][s-x3+1]; if(x1==x2) mid-=a[x1][s-x1+1]; if(x1==x3) mid-=a[x1][s-x1+1]; if(x2==x3) mid-=a[x2][s-x2+1]; if(x1==x2 &amp;&amp; x2==x3) mid+=a[x1][s-x1+1];//容斥原理 f[s][x1][x2][x3]=max(f[s-1][x1][x2][x3],max(f[s-1][x1][x2][x3-1],max(f[s-1][x1][x2-1][x3],max(f[s-1][x1][x2-1][x3-1],max(f[s-1][x1-1][x2][x3],max(f[s-1][x1-1][x2][x3-1],max(f[s-1][x1-1][x2-1][x3],f[s-1][x1-1][x2-1][x3-1]))))))); f[s][x1][x2][x3]+=mid; } printf("%d",f[2*n-1][n][n][n]); return 0; } 注： 思路与传纸条和方格取数相似，但由于数组维数过高（6维）无法直接声明，所以只能压缩维度。通过分析，可以发现y坐标直接与x坐标相关，可以通过步数算出y坐标，同理，x坐标也可以被y坐标算出，这里姑且使用x坐标作为另外三个维度。 循环的时候x从1到n，用x=max(1,s-n+1)，其中1是防止x越界，s-n+1是防止y越界；因为s=x+y-1，所以y=s-x+1&lt;=n，s-n+1&lt;=x，用x&lt;=min(n,s)是防止x越界。 另外，分享一份网络流的题解（wang_yanheng）： 把MAX_CAPACITY改成任意正整数k，即可实现k取方格数主要思路就是拆点构图。把每个点 x 拆成 x1, x2，x1与x2之间有： 一条容量为1，价值为x权值的边 一条容量为MAX_CAPACITY，价值为0的边 假设y, z分别为 x 右侧、下方的点，把 x2 与 y1、x2 与 z1 各连一条边，容量为MAX_CAPACITY，价值为0最后加上源点与汇点，最大费用流即可。我使用了SPFA寻找最长价值的路径。 解释一下变量含义： edge类型中，next指向的是同一起点的下一条边在E中的位置 E是边集，size 是 E 的大小 headIndex[i] 指向的是起点为 i 的头一条边在E中的位置 used, dist, queue, prev 用于最长路算法，其中 prev[i] 记录最长路中通往点 i 的边在E中的位置 #include &lt;bits/stdc++.h> #define NIL -1 #define MAX_CAPACITY 3 #define INF 10000000 #define MIN(a,b) ((a)&lt;(b)?(a):(b)) using namespace std; typedef struct{ int next; int from, to, value, f; } edge; edge E[5000]; int headIndex[1000]; int size = 0; short used[1000]; int queue[10000]; int dist[1000]; int prev[1000]; void addEdge1(int from, int to, int value, int capacity); void addEdge(int from, int to, int value, int capacity); int maxPath(int source, int sink, int numV); int maxValueFlow(int source, int sink, int numV); int main(){ int n, numV; int x, y, source, sink, value; scanf("%d", &amp;n); /*initialize*/ for(x=0; x&lt;1000; x++) headIndex[x] = NIL; /*build the network*/ numV = 0; for(x=0; x&lt;n; x++){ for(y=0; y&lt;n; y++){ scanf("%d", &amp;value); addEdge(numV, numV+1, value, 1); //connect numV &amp; numV+1 addEdge(numV, numV+1, 0, MAX_CAPACITY); if(x &lt; n-1) addEdge(numV+1, numV+2*n, 0, MAX_CAPACITY); //connnect numV+1 &amp; its downer neighbour, if exists if(y &lt; n-1) addEdge(numV+1, numV+2, 0, MAX_CAPACITY); //connnect numV+1 &amp; its righter neighbour, if exists numV += 2; } } source = numV, sink = numV+1; addEdge(source, 0, 0, MAX_CAPACITY); //source addEdge(numV-1, sink, 0, MAX_CAPACITY); //sink /*solve*/ printf("%d\n", maxValueFlow(source, sink, numV+2)); return 0; } void addEdge1(int from, int to, int value, int capacity){ E[size].from = from; E[size].to = to; E[size].value = value; E[size].f = capacity; E[size].next = headIndex[from]; headIndex[from] = size; size++; } void addEdge(int from, int to, int value, int capacity){ addEdge1(from, to, value, capacity); addEdge1(to, from, -value, 0); } int maxPath(int source, int sink, int numV){ int i, head = 0, tail = 0; for(i=0; i&lt;numV; i++){ used[i] = 0; prev[i] = NIL; dist[i] = -INF; } dist[source] = 0; queue[tail++] = source; while(head &lt; tail){ source = queue[head]; used[source] = 0; i = headIndex[source]; while(i != NIL){ if(E[i].f > 0 &amp;&amp; dist[E[i].to] &lt; dist[source] + E[i].value){ dist[E[i].to] = dist[source] + E[i].value; prev[E[i].to] = i; if(!used[E[i].to]){ queue[tail++] = E[i].to; used[E[i].to] = 1; } } i = E[i].next; } head++; } return dist[sink]; } int maxValueFlow(int source, int sink, int numV){ int path, v, augment, value, ret = 0; while((value = maxPath(source, sink, numV)) > 0){ augment = INF; for(v=sink; v!=source; ){ path = prev[v]; augment = MIN(augment, E[path].f); v = E[path].from; } for(v=sink; v!=source; ){ path = prev[v]; E[path].f -= augment; E[path^1].f += augment; v = E[path].from; } ret += value*augment; } return ret; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[%I64d & %lld: 64位整数全解]]></title>
      <url>http://soyjuice.tk/2016/09/24/I64d-and-lld/</url>
      <content type="text"><![CDATA[64位整形引起的混乱主要在两方面，一是数据类型的声明，二是输入输出。首先是列举出下表的总结： 变量定义输出方式gcc(mingw32)g++(mingw32)gcc(linux i386)g++(linux i386)MicrosoftVisual C++ 6.0long long“%lld”错误错误正确正确无法编译long long“%I64d”正确正确错误错误无法编译int64“lld”错误错误无法编译无法编译错误int64“%I64d”正确正确无法编译无法编译正确long longcout非C++正确非C++正确无法编译__int64cout非C++正确非C++无法编译无法编译 可以看出如果我们在自己机器上写程序的话，情况分类如下： (1) 在Windows下的VC6.0里面，声明数据类型的时候应该写作 __int64 a; 输入输出的时候用 %I64d scanf(”%I64d”,&amp;a);printf(”%I64d”,a); (2) 在linux下的gcc/g++里面，数据类型声明写作 long long a; 输入输出时候用 %lld (3) 在Windows下的其它IDE里面，数据类型声明用上面两种均可 输入输出用 %I64d ================== 以下可无视 ========================= 以下是对这种混乱情况的解释，如无兴趣可以跳过 首先要说的是，和Java等语言不同，C/C++本身并没有规定各数据类型的位数，只是限定了一个大小关系，也就是规定从所占的bit数来说，short &lt;= int &lt;= long &lt;= long long。至于具体哪种类型占用多少位，是由你所用的开发平台的编译器决定的。在现在的PC上一个通常的标准是，int和long同为32位，long long为64位。但是如果换到其它平台(如ARM)上，这个数字可能会有不同，类型所占的大小可以用sizeof()运算符查看。 long long是C99标准中新引进的数据类型，在古老的VC6.0中并没有这个类型，所以在VC6.0中用”long long”会发生编译错误。为了表示64位整数，VC6里采用的是微软自己搞出来的一个数据类型，叫做int64，所以如果你是在VC6.0下编译的话，应该用int64定义64位整型。新版的Visual Studio已经支持long long了。GCC是支持long long的，我们在win系统中使用的其它IDE如Dev-Cpp, Code::Blocks等等大多是采用的MinGW编译环境，它是与GCC兼容的，所以也支持long long（另外为了与MS兼容，也支持__int64）。如果是在纯的linux下，就只能使用long long了。 关于使用printf的输入输出，这里就有一个更囧的情况。实际上只要记住，主要的区分在于操作系统：如果在Windows系统下，那么无论什么编译器，一律用%I64d；如果在Linux系统，一律用%lld。这是因为MS提供的msvcrt.dll库里使用的就是%I64d的方式，尽管Dev-Cpp等在语法上支持标准，但也不得不使用MS提供的dll库来完成IO，所以就造成了这种情况。 ==================== 无视至此 =========================== 那么对OIer来说，最为关心的就是在各个OJ上交题应分别使用哪种方式了。 其实方式只有有限的几种： 如果服务器是linux系统，那么定义用long long，IO用%lld。如果服务器是Windows系统，那么声明要针对编译器而定：如果用MS系列编译器，声明用__int64 [现在新版的Visual Studio也支持long long了] ；如果用MinGW环境，声明用long long，至于无论什么编译器，IO一律%I64d。 下面把各大OJ情况列表如下： 1.Vijos：Windows系统； 2.COGS：Linux系统； 3.洛谷：Linux系统； 4.Tyvj：VJ已死，有事烧纸（Windows系统）； 5.TOJ：Linux系统； ZOJ : Linux系统； POJ : Windows系统。 //本文改自Zlei的博文。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VIJOS P1095 约瑟夫问题10E100版]]></title>
      <url>http://soyjuice.tk/2016/09/23/vijos-p1095-10E%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
      <content type="text"><![CDATA[【描述】n个人排成一圈。从某个人开始，按顺时针方向依次编号。从编号为1的人开始顺时针“一二一”报数，报到2的人退出圈子。这样不断循环下去，圈子里的人将不断减少。由于人的个数是有限的，因此最终会剩下一个人。试问最后剩下的人最开始的编号。 【格式】输入格式一个正整数n，表示人的个数。输入数据保证数字n不超过100位。 输出格式一个正整数。它表示经过“一二一”报数后最后剩下的人的编号。 【样例】样例输入9 样例输出3 【限制】各个测试点1s 【提示】样例说明当n=9时，退出圈子的人的编号依次为：2 4 6 8 1 5 9 7最后剩下的人编号为3 【来源】Matrix67 根据经典问题改编 注：竟然又是他。。。大犇只做数学类型的题吗？ 【分析】题目分析：常见的约瑟夫问题，设f[i]为i个人中最后一个死的人，f[1]=0，f[i]=(f[i-1]+k)%i，但是由于n的位数过大，所以并不能直接递推； 算法分析：可以使用k为2的约瑟夫问题一般性的规律：求出不大于i的最大的2的整数次幂，记为2^k，最后一个去死的人是2(i-2^k)+1，另外再加上高精度； 数据分析：一百位的数据，显然需要高精度计算； 代码分析： #include #include using namespace std; int bigger(int a[],int b[]) { if(a[0]!=b[0]) return a[0]>b[0]; int flag=999; for(int i=a[0];i>=1;i--) if(a[i]!=b[i]) { flag=a[i]>b[i]; break; } if(flag==999) return 0; return flag; } int read(int a[]) { char c[1000]; scanf("%s",c); int n=1,len=strlen(c),k=1; for(int i=0;ib[0]?a[0]:b[0]; for(int i=1;i1) len--; c[0]=len; } int minusx(int a[],int b[],int c[]) { int len=a[0]; for(int i=1;i=1;i--) printf("%04d",a[i]); } int main() { int n[100]={0}; read(n); int flag; int temp[100],base[100]={1,1}; while(true) { flag=1; base[1]--; flag*=bigger(n,base); base[1]++; memcpy(temp,base,sizeof(temp)); mult(base,2); flag*=bigger(base,n); if(flag) break; } int c[100]={0}; temp[1]--; minusx(n,temp,c); mult(c,2); int m[100]={1,1}; memset(temp,0,sizeof(temp)); minusx(c,m,temp); output(temp); return 0; } 高精度x低精度，每次乘完，比较一次n与上一行末尾的数、n与下一行开头的数的大小得到n在不在该行中，不在就继续乘如果在该行中，那么n就是该行第（n-上一行末尾的序号）个（高精度减法）然后2k-1 得到结果 （高精度减法，乘法）注：计算上一行末尾，即（2^n）-1时，直接在a[1] 减1即可。因为2的乘方末尾最小为2 注：以上借用了chronix同学代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VIJOS P1090 连续数之和]]></title>
      <url>http://soyjuice.tk/2016/09/22/vijos-p1090-%E8%BF%9E%E7%BB%AD%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="text"><![CDATA[【描述】有n个正整数排成一行。你的目的是要从中取出一个或连续的若干个数，使它们的和能够被k整除。 例如，有6个正整数，它们依次为1、2、6、3、7、4。若k=3，则你可以取出1、2、6，或者2、6、3、7，也可以仅仅取出一个6或者3使你所取的数之和能被3整除。当然，满足要求的取法不止以上这4种。事实上，一共有7种取法满足要求。 给定n和k，以及这n个数。你的任务就是确定，从这n个数中取出其中一个数或者若干连续的数使它们的和能被k整除有多少方法。由于取法可能很多，因此你只需要输出它mod 1234567的值即可。 【格式】输入格式第一行有两个正整数，分别代表n和k。输入数据保证有n&lt;=500 000，k&lt;=100 000。 以下n行每行一个正整数。这些正整数保证都不大于10 000。 输出格式一个正整数。它应该是你的答案mod 1234567的结果。 【样例】样例输入16 3126374 样例输出17 【限制】各个测试点1s 【来源】Matrix67 根据经典问题改编 注：Matrix67乃文科班的数学奇人，这是他的博客。 【分析】题目分析：从这n个数中取出其中一个数或者若干连续的数使它们的和能被k整除有多少方法，方法应该很多，并且n的总类又非常多，所以需要想一想所有的加和之间的共同性； 算法分析：思考后发现，因为对k求余，所以可以将每一次的总数取模，这样每一次的总数都被归了类，再通过加法原理统计每一个方法； 数据分析：输入数据保证有n&lt;=500 000，k&lt;=100 000，这些正整数保证都不大于10 000，每一个数都不算特别大，正好应证了想法； 代码分析： #include&lt;bits/stdc++.h&gt; using namespace std; int n,k,tmp; unsigned long long sum=0,ans=0,f[100001]; int main() { scanf("%d%d",&amp;n,&amp;k); memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++) { scanf("%d",&amp;tmp); sum+=tmp; if(sum%k==0) ans++; ans=(ans+f[sum%k])%1234567; f[sum%k]++; } printf("%I64d",ans); return 0; } 刚开始还在纠结如何将归类好的数据算出方法总数，后来发现每一个数出现时，就可以将所属分类的数加起来，这样每一次就是将已有的可能性加上出现这个数后所有的可能性。 借用hsez_woixia1314同学的题解： SUM[i]是代表前i个数的和当(SUM[i]-SUM[j]) MOD k=0 这时[j+1,i]就是满足的一个区间 一个方案了而我们求的是(SUM[i]-SUM[j]) MOD k=0 这样的方案总个数我们又可以推出 上式等价于SUM[i] MOD k=SUM[j] MOD k所以我们就是求SUM[i] MOD k=SUM[j] MOD k 的方案个数了假设 sum[i],sum[j],..sum[k]（共bn个） 都是 MOD k 余数为k-1的sum那么从上面bn个sum中任意选取两个就能得出(SUM[i]-SUM[j]) MOD k=0那么在bn个sum中怎么配对呢（下面的sum[bn]表示上述bn个sum中的第n个sum）很简单 先是sum[b1]与sum[b2] sum[b3] …sumbn然后sum[b2]与sum[b3] sum[b4] …sumbn然后sum[b3]与sum[b4] sum[b5] …sumbn…………最后sum[bn-1]与sum[bn] ( 1 个)方案总数=n-1+n-2+n-3+…+1=bn(bn-1) div 2（好像这是初中的知识吧？ 可是当时我看楼下的楼下的楼下….的题解 我一时竟然还不明白为什么）所以 当sum mod k的余数为k-1时有bn(bn-1) div 2个方案总数了就这样依次得出余数为k-1 k-2 k-3 …0的时候方案总数 再相加一下得出答案所以在读入一个数的时候就计算sum然后计算sum mod k 的余数而b[j]表示余数为j的sum个数 此时根据上面新得出的更新相应的b[j]这样在读入完毕之后就可以根据b[j]直接计算总方案数了特别值得注意的是！！！！计算余数为0的方案总数时候还要加上b[0] 也就是b[0]*(b[0]-1) div 2+b[0]为什么？？ 因为余数为0的时候单独一个sum[i]就能成为一个方案了还有比如div 2可以用shr 1 这样可以加快速度呼呼(～ o ～)~zZ 说得好累啊我自己都快被讲糊涂了 呵呵希望有不懂这道题目的人能看懂….这样就不算白忙了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划专练（一）]]></title>
      <url>http://soyjuice.tk/2016/09/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="text"><![CDATA[1.数字三角形描述示出了一个数字三角形。 请编一个程序计算从顶至底的某处的一条路径，使该路径所经过的数字的总和最大。每一步可沿左斜线向下或右斜线向下走；1&lt;三角形行数&lt;25；三角形中的数字为整数&lt;1000； 输入格式第一行为N，表示有N行后面N行表示三角形每条路的路径权 输出格式路径所经过的数字的总和最大的答案 测试样例1输入 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 输出 30 备注搜索80，记忆化AC。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=30; vector ve[up]; int f[up][up]; int dfs(int x,int y) { if(f[x][y]) return f[x][y]; return f[x][y]=ve[x][y]+max(dfs(x+1,y),dfs(x+1,y+1)); } int main() { //freopen("djs.in","r",stdin); //freopen("djs.out","w",stdout); int i=0,j=0,n,m; cin&gt;&gt;n; for(i=0;i&lt;n;i++) for(j=0;j&lt;=i;j++) { cin&gt;&gt;m; ve[i].push_back(m); if(i==n-1) f[i][j]=m; } cout&lt;&lt;dfs(0,0)&lt;&lt;endl; return 0; } 2.方格取数题目描述设有N*N的方格图(N&lt;=9)，我们将其中的某些方格中填入正整数，而其他的方格中则放 人数字0。如下图所示（见样例）： A 0 0 0 0 0 0 0 0 0 0 13 0 0 6 0 0 0 0 0 0 7 0 0 0 0 0 0 14 0 0 0 0 0 21 0 0 0 4 0 0 0 0 15 0 0 0 0 0 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0 . B 某人从图的左上角的A点出发，可以向下行走，也可以向右走，直到到达右下角的B 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。 此人从A点到B点共走两次，试找出2条这样的路径，使得取得的数之和为最大。 输入输出格式输入格式： 输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个 表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。 输出格式： 只需输出一个整数，表示2条路径上取得的最大的和。 输入输出样例输入样例#1：82 3 132 6 63 5 74 4 145 2 215 6 46 3 157 2 140 0 0 输出样例#1：67 说明NOIP 2000 提高组第四题 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int n; int a[10][10]= {0}; int f[10][10][10][10]= {0}; int main() { cin&gt;&gt;n; while(true) { int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(x==0) break; a[x][y]=z; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) for(int l=1;l&lt;=n;l++) { f[i][j][k][l]=max(max(f[i-1][j][k-1][l],f[i-1][j][k][l-1]),max(f[i][j-1][k-1][l],f[i][j-1][k][l-1]))+a[i][j]; if (i!=k &amp;&amp; j!=l) f[i][j][k][l]+=a[i][j]; } cout&lt;&lt;f[n][n][n][n]&lt;&lt;endl; return 0; } 3.传纸条题目描述小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。 还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。 输入输出格式输入格式： 输入文件message.in的第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1&lt;=m,n&lt;=50）。 接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。 输出格式： 输出文件message.out共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。 输入输出样例输入样例#1：3 30 3 92 8 55 7 0 输出样例#1：34 说明【限制】 30%的数据满足：1&lt;=m,n&lt;=10 100%的数据满足：1&lt;=m,n&lt;=50 NOIP 2008提高组第三题 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int up=55; int ans[up][up],dis[up][up][up][up]; int main() { int n,m; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;ans[i][j]; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=m;k++) for(int l=1;l&lt;=n;l++) { dis[i][j][k][l]=max(max(dis[i-1][j][k-1][l],dis[i-1][j][k][l-1]),max(dis[i][j-1][k-1][l],dis[i][j-1][k][l-1]))+ans[i][j]; if(i!=k &amp;&amp; j!=l) dis[i][j][k][l]+=ans[k][l]; } cout&lt;&lt;dis[m][n][m][n]&lt;&lt;endl; return 0; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[停止更新]]></title>
      <url>http://soyjuice.tk/2016/09/18/%E5%81%9C%E6%AD%A2%E6%9B%B4%E6%96%B0/</url>
      <content type="text"><![CDATA[很抱歉，由于备战NOIP，个别分类将会停止再更新，所以，其实也没有所以。另外，最近有一部特别好的影片《君の名は。》，安利一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VIJOS P1449 字符串还原]]></title>
      <url>http://soyjuice.tk/2016/09/11/vijos-p1449-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%98%E5%8E%9F/</url>
      <content type="text"><![CDATA[【背景】小K是一位蔚蓝教主的崇拜者(Orz教主er)，有一天，他收到了一封匿名信，信告诉了小K由于他表现出色，得到了一次当面Orz教主的机会，但是要当面Orz教主可不那么容易，不是每个人都有资格Orz教主的。所以要破解下面一段密文才可以得到相关的信息，信中有提供加密的规则，但是小K觉得这个问题看似复杂，所以想请你帮忙。 【描述】一个长度为n的由小写字母组成的字符串S1 S2 … Sn按如下方式加密成3种形式： 1、将字符串翻转，即对于每一个1≤i≤n来说，Si Si 与Sn−i+1 Sn−i+1 对换。2、将字符串中每个字母变为其之后第k个字母，定义z之后的字母为a，其中0≤k≤6且为未知数。3、将字符串中每个字母变为其之前第k个字母，定义a之前的字母为z，k同2所述。 例如字符串abcd按上面3种方式加密后，在k=1的情况下会依次变为： 1、dcba；2、bcde；3、zabc。 现给出信中按以上3种形式分别加密后的3个字符串（不一定按上述例子的顺序），要求还原原来的字符串，并输出告诉小K。 【格式】输入格式输入的第1行为一个整数n，表示这个字符串的长度。 下面3行每行3个长度为n的字符串，且保证符合题目要求。 输出格式输出仅包括1行，为还原后的字符串。 【样例】样例输入4zabcdcbabcde 样例输出abcd 【限制】对于10%的数据，输入给出加密字符串的顺序同题目中1、2、3的顺序。 对于20%的数据，n≤5；对于40%的数据，n≤10；对于60%的数据，n≤255；对于100%的数据，n≤10000。 时限1s 【分析】题目分析：三个字符串各有差别，但一个前移一个后移有所联系，可以从此入手； 算法分析：模拟； 数据分析：数据不算太强； 代码分析： #include&lt;bits/stdc++.h&gt; using namespace std; inline int idx(char ch) { return ch; } const int up=10000 +10; char str[4][up]; int n; bool judge(char a, char b, char c) { return ((2*idx(a)==idx(b)+idx(c))||(2*idx(a)==idx(b)+idx(c)+26)||(2*idx(a)==idx(b)+idx(c)-26)); } bool check(int c) { int a,b; switch(c) { case 1:a=2;b=3;break; case 2:a=1;b=3;break; default:a=1;b=2; } for(int i=1;i&lt;=n;i++) if(!judge(str[c][n-i+1], str[a][i], str[b][i])) return false; return true; } int main() { int ans=0; scanf("%d",&amp;n);getchar(); for(int i=1;i&lt;=3;i++) scanf("%s",str[i]+1); for(int i=1;i&lt;=2;i++) if(check(i)) { ans=i; break; } if(!ans) ans=3; for(int i=n;i&gt;=1;i--) printf("%c",str[ans][i]); return 0; } 可以先实验前两个句子的可行性，然后选择正确的那个。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pre：从零开始的游戏人生（二）游戏画面绘图]]></title>
      <url>http://soyjuice.tk/2016/08/05/Pre%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E7%BB%98%E5%9B%BE/</url>
      <content type="text"><![CDATA[2.1 基本屏幕绘图GDI（Graphics Device Interface）译为“图形设备接口”，是WIndows API 中相当重要的一个成员，它掌管了所有显像设备的图像显示及输出功能，而本文将会讲解GDI函数的使用及窗口黏贴图像的技巧，渐进式地学习如何绘制所需的游戏画面。 2.1.1 坐标与DC&nbsp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pre：从零开始的游戏人生（一）Windows API 程序基础]]></title>
      <url>http://soyjuice.tk/2016/08/01/Pre%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F%EF%BC%88%E4%B8%80%EF%BC%89Windows%20API%20%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</url>
      <content type="text"><![CDATA[1.1 VC++与Windows API由于计算机游戏融合了大量声音，影像数据的运算处理，因此，流畅度是程序运行时相当重要的一个基本要求。 为了达到这项要求，目前一般的大型游戏软件开发大多采用VC++（Visual C++）程序开发工具与Windows API（Application Program Interface）程序框架来编写，以提高运行效率。在VC++IDE中，编写Windows操作系统平台的窗口程序有两种不同的程序架构：一种是微软加入的MFC（Microsoft Foundation Class library）类函数库；另一种便是本文所述的Windows API。 其实，Windows API开发并不易，但在游戏开发上却相当简单且具有较优越的运行性能。 注：所以还是使用VS吧，code::blocks也行，反正都比VC++顺手。 1.2 构建游戏设计的舞台1.2.1 建立程序项目如果是在VC++中，可以选择“新建”，然后选择“Win32 Application”，单击【OK】按钮。 项目建立完成后，可以了解到项目中几个重要的文件： canvas.cpp 主程序文件，其中包含整个项目的主程序WinMaincanvas.rc 资源文件，定义了整个项目所使用的资源StdAfx.h 标头文件，其中引用整个项目所需的头文件 写完调试好之后，直接摁F5运行即可。 1.2.2 程序架构说明上文中表格便是一个标准的Windows API的程序架构，主程序文件“canvas.cpp”由下表中的几个重要的函数构成。 函数名称说明WinMain主程序，程序起始点WndProc自定义函数，处理程序消息MyRegisterClass自定义函数，注册窗口类别InitInstance自定义函数，建立及显示窗口的初始化函数 1.2.2.1 WinMain函数主程序，如同Console中的main()函数。 int APIENTRY WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { MSG msg; MyRegisterClass (hInstance); if (!InitInstance (hInstance, nCmdShow)) { return FALSE; } while (GetMessage (&amp;msg, NULL, 0, 0)) { TranslateMessage (&amp;msg); DispatchMessage (&amp;msg); } return msg.wParam; } 程序说明： (1)调用MyRegisterClass()函数，向系统注册窗口类别，输入参数“hInstance”是目前运行个体的对象代码。 (2)调用InitInstance()函数，进行初始化操作。 (3)通过此消息循环来获取消息，并进行必要的键盘消息转换，而后将控制权交给操作系统，由操作系统决定该由哪个程序的消息处理程序，这个循环使用下述的API函数4,5,6。 (4)GetMessage()，获取程序消息。 (5)TranslateMessage()，转换伪码及字符。 (6)DispatchMessage()，将控制权交给系统，再由系统决定负责处理消息的程序。 1.2.2.2 MyRegisterClass()函数在建立程序窗口的实体前，必须先定义一个窗口类别，其中包含所要建立窗口的相关信息。 ATOM MyRegisterClass (HINSTANCE hInstance) { WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = (WNDPROC)WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = NULL; wcex.hCursor = NULL; wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wcex.lpszMenuName = NULL; wcex.lpszClassName = "canvas"; wcex.hIconSm = NULL; return RegisterClassEx(&amp;wcex); } 程序说明： (1)声明一个窗口类别“WNDCLASSEX”和结构“wcex”。 (2)定义“wcex”中的各项信息，其中设定消息处理函数（lpfnWndProc）为“WndProc”，类别名称（lpszClassName）为“canvas”。 (3)调用RegisterClassEx()函数注册类别，返回一个“ATOM”形态的字符串，即为类别名称“canvas”。 1.2.2.3 InitInstance()函数在这一初始函数中，按照前面所定义的窗口类别来建立并显示实际的程序窗口。 BOOL InitInstance (HINSTANCE hInstance, int nCmdShow) { HWND hWnd; hInst = hInstance; hWnd = CreateWindow("canvas", "A2's Ghost", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL); if(!hWnd) { return FALSE; } MoveWindow(hWnd, 10, 10, 600, 450, true); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); return TRUE; } 程序说明： (1)调用CreateWindow()函数来创建一个窗口对象，所输入的第一个参数就是窗口建立所依据的类别名称，也就是前面程序所定义的“canvas”。 (2)设定窗口的显示位置及窗口大小，然后绘制在显示设备上，使用了下述API函数。 (3)MoveWindow()，设定窗口显示的位置及窗口大小。 (4)ShowWindow()，设定窗口显示时的状态。 (5)UpdateWindow()，将窗口绘制在显示设备上。 1.2.2.4 WndProc()函数前面设定的时候把WndProc定义为消息处理函数，也就是当某些外部消息发生时，会按照消息的类型来决定该如何进行处理，除此之外，WndProc也是一个回叫函数（CALLBACK）是属于Windows操作系统所调用的函数，而非程序本身调用的程序。 LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) { PAINTSTRUCT ps; HDC hdc; switch (message)//(1) { case WM_PAINT://(2) hdc = BeginPaint (hWnd, &amp;ps); EndPaint (hWnd, &amp;ps); break; case WM_DESTROY://(3) PostQuitMessage (0); break; default://(4) return DefWindowProc (hWnd, message, wParam, lParam); } return 0; } 程序说明： (1)判断消息类型。 (2)处理窗口重绘消息。 (3)处理窗口结束消息。 (4)使用函数调用预设的系统函数处理程序本身不处理的消息。 1.3 总结本文讨论了VC++在游戏开发上所具备的优点，并快速地浏览了API程序的基本框架，希望可以对观看此文的人有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[COGS P1 A+B Problem]]></title>
      <url>http://soyjuice.tk/2016/07/17/COGS%20P1%20A+B%20Problem/</url>
      <content type="text"><![CDATA[【背景】现在有两个实数，分别是A和B。请你从文件中读取A和B，计算它们的和A+B，并把它输出到文件中。（保留到整数） 【格式】输入格式第一行：一个实数A第二行：一个实数B 输出格式第一行：一个整数C = A+B 【样例】输入样例12 输出样例3 【分析】题目分析：第一感觉是太简单了，作为基础题也不应该这么平凡，仔细一看，发现有一些小改动，不好好读题的话就会出错，COGS无愧人气高； 算法分析：直接模拟； 数据分析：4个数据，比较水； 代码分析： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int main() { freopen("aplusb.in","r",stdin); freopen("aplusb.out","w",stdout); double a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;(int)(a+b)&lt;&lt;endl; return 0; } 没什么好分析的，他教会了我们必须好好读题干； alert(“My First JavaScript”); P.S.这道题只是一个报告模板。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Index]]></title>
      <url>http://soyjuice.tk/2016/07/17/index/</url>
      <content type="text"><![CDATA[There is some strange thing.What is it? It’s my blog. 1-saber 2-dalao 3-who 4-interesting &nbsp;]]></content>
    </entry>

    
  
  
</search>
